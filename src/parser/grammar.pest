WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }

program = { SOI ~ ( (statement | function_definition) ~ (WHITESPACE* ~ COMMENT*) )* ~ EOI }

statement = { assignment | print_statement | if_statement | while_statement | for_statement | function_definition | return_statement | expression_statement | break_statement | continue_statement | pass_statement }
expression_statement = { expression }

assignment_operator = @{ "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "**=" | "//=" | "&=" | "|=" | "^=" | ">>=" | "<<=" }
assignment = { identifier ~ assignment_operator ~ expression }

print_statement = { "print" ~ "(" ~ expression ~ ")" }

if_statement = { "if" ~ expression ~ block ~ elif_clause* ~ else_clause? }
elif_clause = { "elif" ~ expression ~ block }
else_clause = { "else" ~ block }

while_statement = { "while" ~ expression ~ block }

for_statement = { "for" ~ identifier ~ "in" ~ expression ~ block }

block = { "{" ~ statement* ~ "}" }

expression = _{ logical_or }

logical_or_op = @{ "or" }
logical_or = { logical_and ~ (logical_or_op ~ logical_and)* }

logical_and_op = @{ "and" }
logical_and = { logical_not_expr ~ (logical_and_op ~ logical_not_expr)* } // Changed from comparison to logical_not_expr

logical_not_op = @{ "not" }
logical_not_expr = { logical_not_op ~ comparison_identity_membership | comparison_identity_membership } // logical_not is unary

// Combined comparison, identity, and membership operators
comparison_identity_membership = { bitwise_or ~ (comp_ident_member_op ~ bitwise_or)* }
comp_ident_member_op = @{ "==" | "!=" | ">=" | "<=" | ">" | "<" | "is not" | "is" | "not in" | "in" }

bitwise_or_op = @{ "|" }
bitwise_or = { bitwise_xor ~ (bitwise_or_op ~ bitwise_xor)* }

bitwise_xor_op = @{ "^" }
bitwise_xor = { bitwise_and ~ (bitwise_xor_op ~ bitwise_and)* }

bitwise_and_op = @{ "&" }
bitwise_and = { shift ~ (bitwise_and_op ~ shift)* }

shift_op = @{ "<<" | ">>" }
shift = { add_sub ~ (shift_op ~ add_sub)* }

add_sub = { mul_div_mod ~ (add_op ~ mul_div_mod)* }
add_op = @{ "+" | "-" }

mul_div_mod = { unary_bitwise_not_power ~ (mul_op ~ unary_bitwise_not_power)* } // Changed from power to unary_bitwise_not_power
mul_op = @{ "*" | "//" | "/" | "%" }

unary_bitwise_not_op = @{ "~" }
// Power and unary bitwise NOT have similar precedence, handled by structure.
// Unary + and - are typically handled by factor if needed, but Python's model is slightly different.
// For now, ~ is grouped with power. 'not' is higher.
unary_bitwise_not_power = { unary_bitwise_not_op ~ power | power }

power = { factor ~ (pow_op ~ factor)* }
pow_op = @{ "**" }

atom = {
    lambda_expression |
    list_literal |
    tuple_literal |
    dict_literal |
    set_literal |
    frozenset_literal |
    complex_literal |
    float_literal |
    integer_literal |
    string_literal |
    none_literal |
    identifier |
    "(" ~ expression ~ ")"
}

factor = { atom ~ call_suffix* }
call_suffix = { "(" ~ argument_list? ~ ")" }
lambda_expression = { "lambda" ~ parameter_list? ~ ":" ~ expression }
argument_list = { expression ~ ("," ~ expression)* }

float_literal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
integer_literal = @{ ASCII_DIGIT+ }
string_literal = @{ "\"" ~ (char* ) ~ "\"" }
none_literal = @{ "None" } // Added for None
char = { !("\"" | "\\") ~ ANY }
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
NEWLINE = _{ "\r"? ~ "\n" }

function_definition = { "def" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ block }
parameter_list = { identifier ~ ("," ~ identifier)* }

return_statement = { "return" ~ expression? }

break_statement = { "break" }
continue_statement = { "continue" }
pass_statement = { "pass" }

list_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" } // Added for list literals
tuple_literal = { "(" ~ expression ~ ("," ~ expression)+ ~ ")" }
dict_literal = { "{" ~ (dict_entry ~ ("," ~ dict_entry)*)? ~ "}" }
dict_entry = { expression ~ ":" ~ expression }
set_literal = { "{" ~ expression ~ ("," ~ expression)* ~ "}" }
frozenset_literal = { "frozenset" ~ "(" ~ list_literal ~ ")" }
complex_literal = { "complex" ~ "(" ~ expression ~ "," ~ expression ~ ")" }
